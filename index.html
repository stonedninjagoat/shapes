<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>shapes table</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<style>
body { font-family: Arial, sans-serif; margin: 20px; }
#column-checkboxes, #sort-instructions { margin: 10px 0; }
label { margin-right: 10px; }
.table-container { display: flex; }
.row-numbers, .table-wrapper { overflow-y: auto; max-height: 400px; }
.row-numbers { text-align: right; margin-right: 5px; font-size: 12px; line-height: 22px; }
table { border-collapse: collapse; table-layout: auto; width: max-content; min-width: 100%; }
th, td { border: 1px solid black; padding: 5px; text-align: left; white-space: nowrap; }
thead th { position: sticky; top: 0; background: #eee; z-index: 2; }
.sort-indicator { font-size: 8px; color: gray; margin-left: 2px; }
th.sortable { cursor: pointer; text-decoration: underline; }
</style>
</head>
<body>

<h2>Upload CSV and Aggregate Shape Counts</h2>
<input type="file" id="csvFile" accept=".csv" />
<div id="column-checkboxes"></div>
<div id="sort-instructions"></div>
<div class="table-container">
  <div class="row-numbers" id="rowNumbers"></div>
  <div class="table-wrapper">
    <table id="csvTable"></table>
  </div>
</div>

<script>
let originalData = [];
let headers = [];
let sortPriority = [];
const shapeCountCol = 'shape_count';

const csvFileInput = document.getElementById('csvFile');
const checkboxesDiv = document.getElementById('column-checkboxes');
const sortInstructionsDiv = document.getElementById('sort-instructions');
const csvTable = document.getElementById('csvTable');
const rowNumbersDiv = document.getElementById('rowNumbers');
const tableWrapperDiv = document.querySelector('.table-wrapper');

// Upload CSV
csvFileInput.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;

  Papa.parse(file, {
    header: true,
    skipEmptyLines: true,
    dynamicTyping: true,
    complete: function(results) {
      originalData = results.data.map(row => {
        row[shapeCountCol] = Number(row[shapeCountCol] || 0);
        return row;
      });
      headers = results.meta.fields.filter(f => f !== shapeCountCol);
      renderCheckboxes();
      updateTable();
    }
  });
});

// Render column checkboxes
function renderCheckboxes() {
  checkboxesDiv.innerHTML = '';
  headers.forEach(header => {
    const label = document.createElement('label');
    label.innerHTML = `<input type="checkbox" checked value="${header}"> ${header}`;
    checkboxesDiv.appendChild(label);
  });

  checkboxesDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => {
    cb.addEventListener('change', updateTable);
  });
}

// Update table with aggregation and sorting
function updateTable() {
  const selectedColumns = Array.from(checkboxesDiv.querySelectorAll('input[type="checkbox"]:checked'))
                               .map(cb => cb.value);

  if (selectedColumns.length === 0) {
    csvTable.innerHTML = '<tr><td>No columns selected</td></tr>';
    rowNumbersDiv.innerHTML = '';
    return;
  }

  // Aggregate shape_count based on selected columns
  const groupedData = {};
  originalData.forEach(row => {
    const key = selectedColumns.map(col => row[col] ?? '').join('|');
    if (!groupedData[key]) {
      groupedData[key] = { ...row };
      groupedData[key][shapeCountCol] = 0;
    }
    groupedData[key][shapeCountCol] += row[shapeCountCol];
  });

  let displayData = Object.values(groupedData);

  // Apply multi-level sort
  if (sortPriority.length > 0) {
    displayData.sort((a, b) => {
      for (let s of sortPriority) {
        const valA = a[s.col] ?? '';
        const valB = b[s.col] ?? '';
        if (valA < valB) return s.dir === 'asc' ? -1 : 1;
        if (valA > valB) return s.dir === 'asc' ? 1 : -1;
      }
      return 0;
    });
  }

  renderTable(displayData, selectedColumns);
  renderRowNumbers(displayData.length);
  renderSortInstructions();
}

// Render row numbers
function renderRowNumbers(rowCount) {
  rowNumbersDiv.innerHTML = '';
  for (let i = 1; i <= rowCount; i++) {
    const div = document.createElement('div');
    div.style.height = '22px';
    div.textContent = i;
    rowNumbersDiv.appendChild(div);
  }
}

// Synchronize scrolling
tableWrapperDiv.addEventListener('scroll', () => {
  rowNumbersDiv.scrollTop = tableWrapperDiv.scrollTop;
});

// Render table
function renderTable(data, displayColumns) {
  csvTable.innerHTML = '';
  if (data.length === 0) return;

  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');

  displayColumns.forEach(col => {
    const th = document.createElement('th');
    th.textContent = col;
    th.classList.add('sortable');
    th.addEventListener('click', (e) => { if (e.detail===1) toggleSort(col); });
    th.addEventListener('dblclick', () => removeSort(col));
    const sp = sortPriority.findIndex(s => s.col===col);
    if (sp >=0){ const indicator=document.createElement('span'); indicator.classList.add('sort-indicator'); indicator.textContent = sp+1; th.appendChild(indicator);}
    headerRow.appendChild(th);
  });

  // shape_count at end
  const thCount = document.createElement('th');
  thCount.textContent = shapeCountCol;
  thCount.classList.add('sortable');
  thCount.addEventListener('click', () => toggleSort(shapeCountCol));
  thCount.addEventListener('dblclick', () => removeSort(shapeCountCol));
  const spCount = sortPriority.findIndex(s => s.col===shapeCountCol);
  if(spCount>=0){ const indicator=document.createElement('span'); indicator.classList.add('sort-indicator'); indicator.textContent=spCount+1; thCount.appendChild(indicator);}
  headerRow.appendChild(thCount);

  thead.appendChild(headerRow);
  csvTable.appendChild(thead);

  const tbody = document.createElement('tbody');
  data.forEach(row => {
    const tr = document.createElement('tr');
    displayColumns.forEach(col => {
      const td=document.createElement('td'); td.textContent=row[col]??''; tr.appendChild(td);
    });
    const tdCount=document.createElement('td'); tdCount.textContent=row[shapeCountCol]; tr.appendChild(tdCount);
    tbody.appendChild(tr);
  });
  csvTable.appendChild(tbody);
}

// Toggle sorting
function toggleSort(col){
  const existing=sortPriority.find(s=>s.col===col);
  if(!existing){ if(sortPriority.length>=3) sortPriority.pop(); sortPriority.unshift({col,dir:'asc'});}
  else existing.dir=existing.dir==='asc'?'desc':'asc';
  updateTable();
}

// Remove column from sort
function removeSort(col){
  sortPriority=sortPriority.filter(s=>s.col!==col);
  updateTable();
}

// Display sort instructions
function renderSortInstructions(){
  if(sortPriority.length===0){ sortInstructionsDiv.innerHTML=''; return;}
  sortInstructionsDiv.innerHTML='Sort priority (click headers to toggle A-Z / Z-A, dblclick to remove): '+
    sortPriority.map((s,i)=>`${i+1}: ${s.col} (${s.dir.toUpperCase()})`).join(' | ');
}
</script>

</body>
</html>
