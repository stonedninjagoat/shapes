<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Shapes Table</title>
<link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<style>
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  font-family: 'Ubuntu Mono', monospace;
  display: flex;
  flex-direction: column;
}

body {
  padding: 10px;
}

#controls {
  margin-bottom: 10px;
}

.file-btn, button {
  display: inline-block;
  width: auto;
  font-family: 'Ubuntu Mono', monospace;
  font-size: 14px;
  padding: 5px 10px;
  border: 1px solid #000;
  border-radius: 4px;
  background-color: #eee;
  cursor: pointer;
  margin-right: 10px;
  text-align: center;
  vertical-align: middle;
}

.file-btn {
  position: relative;
  overflow: hidden;
}

.file-btn input[type="file"] {
  position: absolute;
  left: 0;
  top: 0;
  opacity: 0;
  width: 100%;
  height: 100%;
  cursor: pointer;
}

#column-checkboxes, #sort-instructions { margin: 10px 0; }
#color-checkboxes-container label,
#sort-checkboxes-container label,
#group-checkboxes-container label { margin-right: 15px; }
#hide-checkboxes-container label {
    margin-right: 15px; /* Ensure spacing */
    display: inline-flex; /* Helps with background application */
    align-items: center;
}

.closed-col-bg {
  background-color: #e6f0ff; /* Light Blue */
  border-radius: 4px;
  padding: 2px 5px; 
}

.open-col-bg {
  background-color: #ffe6e6; /* Light Red */
  border-radius: 4px;
  padding: 2px 5px;
}


.checkbox-section {
  margin: 10px 0;
  padding: 5px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background-color: #f9f9f9;
}

.checkbox-section-title {
  font-weight: bold;
  margin-right: 10px;
}

.table-container {
  display: flex;
  margin-top: 20px;
  flex-grow: 1; 
}

.row-numbers {
  text-align: right;
  margin-right: 5px;
  font-size: 12px;
  line-height: 1;
  padding-top: 32px;
}

.row-numbers > div {
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: flex-end;
}

.table-wrapper {
  flex: 1;
  overflow-y: auto; 
  overflow-x: auto; 
  scroll-behavior: smooth;
}

table {
  border-collapse: collapse;
  width: 100%;
  table-layout: auto;
  font-family: 'Ubuntu Mono', monospace;
}

th, td {
  border: 1px solid black;
  padding: 5px;
  text-align: center;
  vertical-align: middle;
  white-space: nowrap;
}

thead th {
  position: sticky;
  top: 0;
  background: #f0f0f0;  
  z-index: 10;
  box-shadow: 0 2px 3px rgba(0,0,0,0.15); 
}

th.sortable { cursor: pointer; text-decoration: underline; }
.sort-indicator { font-size: 8px; color: gray; margin-left: 2px; }

</style>
</head>
<body>

<h2>Shapes Table</h2>

<div id="controls">
    <label class="file-btn">
        Choose File
        <input type="file" id="csvFile" accept=".csv" />
    </label>
	<span id="fileNameDisplay" style="margin-left: 5px; font-style: italic;">(Using default file --- for Sam: Joe Robinson Preliminary Guitar Data)<br><br></span> 
	<button id="exportCsvBtn">Export CSV</button>
	<button id="exportPdfBtn">Export PDF</button>
</div>

<div style="margin: 10px 0;">
  <label>
    <input type="checkbox" id="proportionalCountToggle"> Proportional Count (%)
	  </label>
  <label>
    <input type="checkbox" id="hideInsignificantToggle"> Hide Insignificant Rows (< 1%)
  </label>
  <label style="margin-left: 20px;">
    <input type="checkbox" id="collapseOpenStringsToggle"> Collapse Open Strings
  </label>
  <button id="autoArrangeBtn">Auto-Arrange Table</button>
</div>

<div class="checkbox-section" id="display-checkboxes-container">
  <span class="checkbox-section-title">Display Columns:</span>
  <button id="toggleSelectAll" style="margin-left: 10px; padding: 2px 8px; font-size: 12px;">Select All</button>
  <div id="column-checkboxes" style="display: inline;"></div>
</div>

<div class="checkbox-section" id="color-checkboxes-container" style="display: none;">
  <span class="checkbox-section-title">Color By:</span>
  <button id="toggleColorAll" style="margin-left: 10px; padding: 2px 8px; font-size: 12px;">Select All</button>
  <div id="color-checkboxes" style="display: inline;"></div>
</div>

<div class="checkbox-section" id="sort-checkboxes-container" style="display: none;">
  <span class="checkbox-section-title">Sort By:</span>
  <button id="toggleSortAll" style="margin-left: 10px; padding: 2px 8px; font-size: 12px;">Select All</button>
  <div id="sort-checkboxes" style="display: inline;"></div>
</div>

<div class="checkbox-section" id="group-checkboxes-container" style="display: none;">
  <span class="checkbox-section-title">Group Props By:</span>
  <button id="toggleGroupAll" style="margin-left: 10px; padding: 2px 8px; font-size: 12px;">Select All</button>
  <div id="group-checkboxes" style="display: inline;"></div>
</div>

<div class="checkbox-section" id="hide-checkboxes-container" style="display: none;">
  <span class="checkbox-section-title">Hide Columns:</span>
  <button id="toggleHideAll" style="margin-left: 10px; padding: 2px 8px; font-size: 12px;">Select All</button>
  <div id="hide-checkboxes" style="display: inline;"></div>
</div>

<div class="checkbox-section" id="filter-container" style="display: none;">
  <span class="checkbox-section-title">Filter by Value:</span>
  <button id="clearAllFilters" style="margin-left: 10px; padding: 2px 8px; font-size: 12px;">Clear All</button>
  <div id="filter-dropdowns" style="margin-top: 10px;"></div>
</div>

<div id="sort-instructions"></div>

<div class="table-container">
  <div class="row-numbers" id="rowNumbers"></div>
  <div class="table-wrapper">
    <table id="csvTable"></table>
  </div>
</div>
  
<script>
let originalData = [];
let headers = [];
let sortPriority = [];
let selectedOrder = [];
let colorByColumns = [];
let groupByColumns = [];
let hiddenColumns = [];
let proportionalCountEnabled = false;
let isAutoArranged = false;
let originalHeaderOrder = [];
let autoArrangedHeaderOrder = [];
let filtersByColumn = {}; 
let hideInsignificant = false;
let collapseOpenStrings = false;

const shapeCountCol = 'count';
const rainbowColors = [
  "#FF0000", "#FF7F00", "#FFFF00", "#00FF00", "#0000FF", "#4B0082", "#8B00FF",
  "#FF1493", "#00CED1", "#ADFF2F", "#FF6347", "#20B2AA"
];

const csvFileInput = document.getElementById('csvFile');
const checkboxesDiv = document.getElementById('column-checkboxes');
const sortInstructionsDiv = document.getElementById('sort-instructions');
const csvTable = document.getElementById('csvTable');
const rowNumbersDiv = document.getElementById('rowNumbers');
const tableWrapperDiv = document.querySelector('.table-wrapper');
const defaultCsvUrl = 'https://raw.githubusercontent.com/stonedninjagoat/shapes/refs/heads/main/shapesEvery.csv';
const proportionalCountToggle = document.getElementById('proportionalCountToggle');
const hideInsignificantToggle = document.getElementById('hideInsignificantToggle');
const collapseOpenStringsToggle = document.getElementById('collapseOpenStringsToggle');
const exportCsvBtn = document.getElementById('exportCsvBtn'); // **Add this line**
const exportPdfBtn = document.getElementById('exportPdfBtn');

proportionalCountToggle.addEventListener('change', (e) => {
    proportionalCountEnabled = e.target.checked;
    updateTable();
});

hideInsignificantToggle.addEventListener('change', (e) => {
    hideInsignificant = e.target.checked;
    updateTable();
});

collapseOpenStringsToggle.addEventListener('change', (e) => {
    collapseOpenStrings = e.target.checked;
    updateTable();
});

exportCsvBtn.addEventListener('click', () => {
  exportTableDataToCsv();
});

function exportTableDataToCsv() {
  const visibleColumns = selectedOrder.filter(col => !hiddenColumns.includes(col));
  const finalColumns = [...visibleColumns, shapeCountCol];
  let exportData = Object.values(originalData).map(row => ({...row})); 
  
  // Re-aggregate based on current selected columns
  const columnsForAggregation = selectedOrder.filter(col => !hiddenColumns.includes(col));
  const groupedData = {};
  exportData.forEach(row => {
    const key = columnsForAggregation.map(col => row[col] ?? '').join('|');
    if (!groupedData[key]) {
      groupedData[key] = { ...row };
      groupedData[key][shapeCountCol] = 0;
    }
    groupedData[key][shapeCountCol] += row[shapeCountCol];
  });
  
  exportData = Object.values(groupedData);
  
  // Apply filters
  if (Object.keys(filtersByColumn).length > 0) {
    exportData = exportData.filter(row => {
      for (const col in filtersByColumn) {
        const selectedValues = filtersByColumn[col];
        if (selectedValues.length > 0) {
          const rowValue = String(row[col] ?? '');
          if (!selectedValues.includes(rowValue)) {
            return false;
          }
        }
      }
      return true;
    });
  }

  // Use PapaParse to unparse the data
  const csv = Papa.unparse(exportData, {
      columns: finalColumns 
  });

  // Download the CSV file
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  if (link.download !== undefined) { 
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', 'shapes_export.csv');
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
  }
}

// --- EXPORT PDF FUNCTION (No Fixed Page, Full Table) ---
exportPdfBtn.addEventListener('click', async () => {
  const { jsPDF } = window.jspdf;
  const tableWrapper = document.querySelector('.table-wrapper');
  const table = document.getElementById('csvTable');
  
  if (!table) return;

  // Ensure full content visible
  tableWrapper.scrollLeft = 0;
  tableWrapper.scrollTop = 0;

  // Capture at full resolution
  const canvas = await html2canvas(table, {
    scale: 2, // higher quality
    useCORS: true,
    backgroundColor: '#ffffff'
  });

  const imgData = canvas.toDataURL('image/png');
  const pdf = new jsPDF({
    orientation: canvas.width > canvas.height ? 'landscape' : 'portrait',
    unit: 'px',
    format: [canvas.width, canvas.height] // 🔥 Make page same size as the table
  });

  pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
  pdf.save('shapes_table_full.pdf');
});

function loadCsvFromUrl(url) {
  Papa.parse(url, {
    download: true,
    header: true,
    skipEmptyLines: true,
    dynamicTyping: true,
    complete: function(results) {
      originalData = results.data.map(row => {
        row[shapeCountCol] = Number(row[shapeCountCol] || 0);
        return row;
      });
      headers = results.meta.fields.filter(f => f !== shapeCountCol);
	  originalHeaderOrder = [...headers];  
      selectedOrder = [];
	  isAutoArranged = false; 
	  calculateAutoArrangedOrder(); 
      renderCheckboxes();
	  updateSelectAllButtonText();
      updateTable();
    }
  });
}

loadCsvFromUrl(defaultCsvUrl);

csvFileInput.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) {
	fileNameDisplay.textContent = '(No file selected)';
	return;
  }

	fileNameDisplay.textContent = `(${file.name})`; 

  Papa.parse(file, {
    header: true,
    skipEmptyLines: true,
    dynamicTyping: true,
    complete: function(results) {
      originalData = results.data.map(row => {
        row[shapeCountCol] = Number(row[shapeCountCol] || 0);
        return row;
      });
      headers = results.meta.fields.filter(f => f !== shapeCountCol);
	  originalHeaderOrder = [...headers];  
      selectedOrder = [];
	  isAutoArranged = false; 
	  calculateAutoArrangedOrder(); 
      renderCheckboxes();
      updateTable();
    }
  });
});

// Calculate auto-arranged order based on unique value counts
function calculateAutoArrangedOrder() {
  const uniqueCounts = headers.map(header => {
    const uniqueValues = new Set(originalData.map(row => row[header]));
    return { header, count: uniqueValues.size };
  });
  
  // Sort by count (ascending - fewest unique values first)
  uniqueCounts.sort((a, b) => a.count - b.count);
  
  autoArrangedHeaderOrder = uniqueCounts.map(item => item.header);
}

// Auto-Arrange button handler
const autoArrangeBtn = document.getElementById('autoArrangeBtn');
autoArrangeBtn.addEventListener('click', () => {
  isAutoArranged = !isAutoArranged;
  
  // Store which columns are currently selected/displayed
  const currentlySelected = new Set(selectedOrder);
  
  if (isAutoArranged) {
    headers = [...autoArrangedHeaderOrder];
    autoArrangeBtn.textContent = 'Reset to Original Order';
  } else {
    headers = [...originalHeaderOrder];
    autoArrangeBtn.textContent = 'Auto-Arrange Table';
  }
  
  // Rebuild selectedOrder in the new header order, keeping selections
  selectedOrder = headers.filter(h => currentlySelected.has(h));
  
  renderCheckboxes();
  updateTable();
});

// Render column checkboxes
function renderCheckboxes() {
  checkboxesDiv.innerHTML = '';
  headers.forEach(header => {
    const label = document.createElement('label');
	const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.value = header;
	checkbox.checked = selectedOrder.includes(header);
    label.appendChild(checkbox);
    label.appendChild(document.createTextNode(` ${header}`));
    checkboxesDiv.appendChild(label);
	
	if (header.includes('closed_')) {
        label.classList.add('closed-col-bg');
    } else if (header.includes('open_')) {
        label.classList.add('open-col-bg');
    }
	
  });

checkboxesDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => {
  cb.addEventListener('change', (e) => {
    const col = e.target.value;

    if (e.target.checked) {
      selectedOrder.push(col);
    } else {
      selectedOrder = selectedOrder.filter(c => c !== col);
      sortPriority = sortPriority.filter(s => s.col !== col);
      
      colorByColumns = colorByColumns.filter(c => c !== col);
      groupByColumns = groupByColumns.filter(c => c !== col);
      hiddenColumns = hiddenColumns.filter(c => c !== col);
      delete filtersByColumn[col];
    }

    updateSelectAllButtonText();
    updateTable();
    
    // After updateTable renders the special checkboxes, sync them
    setTimeout(() => {
      syncSpecialCheckboxesToDisplay();
    }, 0);
  });
});
updateSelectAllButtonText();
}

function updateSelectAllButtonText() {
  const checkboxes = checkboxesDiv.querySelectorAll('input[type="checkbox"]');
  const allChecked = Array.from(checkboxes).every(cb => cb.checked);
  document.getElementById('toggleSelectAll').textContent = allChecked ? 'Deselect All' : 'Select All';
}

function syncSpecialCheckboxesToDisplay() {
  // Get currently selected display columns
  const selectedDisplayCols = selectedOrder.filter(col =>
    checkboxesDiv.querySelector(`input[value="${col}"]`).checked
  );
  
  // Sync Color checkboxes - check only the selected display columns
  const colorCheckboxes = document.querySelectorAll('#color-checkboxes input[type="checkbox"]');
  colorCheckboxes.forEach(cb => {
    if (selectedDisplayCols.includes(cb.value)) {
      cb.checked = true;
      if (!colorByColumns.includes(cb.value)) {
        colorByColumns.push(cb.value);
      }
    } else {
      cb.checked = false;
      colorByColumns = colorByColumns.filter(c => c !== cb.value);
    }
  });
  updateToggleButtonText('color');
  
  // Sync Group checkboxes - check only the selected display columns
  /*const groupCheckboxes = document.querySelectorAll('#group-checkboxes input[type="checkbox"]');
  groupCheckboxes.forEach(cb => {
    if (selectedDisplayCols.includes(cb.value)) {
      cb.checked = true;
      if (!groupByColumns.includes(cb.value)) {
        groupByColumns.push(cb.value);
      }
    } else {
      cb.checked = false;
      groupByColumns = groupByColumns.filter(c => c !== cb.value);
    }
  });
  updateToggleButtonText('group');*/
  
  // Sync Hide checkboxes - uncheck hidden columns
  const hideCheckboxes = document.querySelectorAll('#hide-checkboxes input[type="checkbox"]');
  hideCheckboxes.forEach(cb => {
    if (hiddenColumns.includes(cb.value)) {
      cb.checked = true;
    } else {
      cb.checked = false;
    }
  });
  updateToggleButtonText('hide');
  
  // Sync Sort checkboxes
  const sortCheckboxes = document.querySelectorAll('#sort-checkboxes input[type="checkbox"]');
  sortCheckboxes.forEach(cb => {
    if (sortPriority.find(s => s.col === cb.value)) {
      cb.checked = true;
    } else {
      cb.checked = false;
    }
  });
  updateToggleButtonText('sort');
}

function updateToggleButtonText(type) {
  const checkboxesId = `${type}-checkboxes`;
  const checkboxesDiv = document.getElementById(checkboxesId);
  const buttonId = `toggle${type.charAt(0).toUpperCase() + type.slice(1)}All`;
  const toggleButton = document.getElementById(buttonId);
  
  if (!checkboxesDiv || !toggleButton) return;
  
  const checkboxes = checkboxesDiv.querySelectorAll('input[type="checkbox"]');
  const allChecked = Array.from(checkboxes).every(cb => cb.checked);
  const anyChecked = Array.from(checkboxes).some(cb => cb.checked);
  
  if (anyChecked && !allChecked) {
    toggleButton.textContent = 'Deselect All';
  } else if (allChecked) {
    toggleButton.textContent = 'Deselect All';
  } else {
    toggleButton.textContent = 'Select All';
  }
}

function autoSelectDisplayColumn(col) {
  const displayCheckbox = checkboxesDiv.querySelector(`input[value="${col}"]`);
  if (displayCheckbox && !displayCheckbox.checked) {
    displayCheckbox.checked = true;
    if (!selectedOrder.includes(col)) {
      selectedOrder.push(col);
    }
    updateSelectAllButtonText();
  }
}

// Render color, sort, and group selection checkboxes
function renderSpecialCheckboxes(visibleCols) {
	const allDisplayCols = [...visibleCols, shapeCountCol];

  // Color By checkboxes
	renderCheckboxGroup('color', visibleCols, colorByColumns);
  
  // Sort By checkboxes
  renderCheckboxGroup('sort', allDisplayCols, sortPriority.map(s => s.col)); 
  
  // Group Props By checkboxes (only visible columns, not count)
  renderCheckboxGroup('group', visibleCols, groupByColumns);
  
  // Hide Columns checkboxes
  renderCheckboxGroup('hide', allDisplayCols, hiddenColumns); 
}

function renderCheckboxGroup(type, columns, selectedCols) {
  const containerId = `${type}-checkboxes-container`;
  const checkboxesId = `${type}-checkboxes`;
  const container = document.getElementById(containerId);
  const checkboxesDiv = document.getElementById(checkboxesId);
  
  if (columns.length === 0) {
    container.style.display = 'none';
    return;
  }
  
  container.style.display = 'block';
  checkboxesDiv.innerHTML = '';
  
  columns.forEach(col => {
    const label = document.createElement('label');
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.value = col;
    checkbox.checked = selectedCols.includes(col);
    
checkbox.addEventListener('change', (e) => {
  const col = e.target.value;
  
  if (type === 'color') {
    if (e.target.checked) {
      if (!colorByColumns.includes(col)) colorByColumns.push(col);
      autoSelectDisplayColumn(col);
    } else {
      colorByColumns = colorByColumns.filter(c => c !== col);
    }
    // Update the Color toggle button text
    updateToggleButtonText('color');	
      } else if (type === 'sort') {
        if (e.target.checked) {
          if (!sortPriority.find(s => s.col === col)) {
            sortPriority.push({ col, dir: 'asc' });
          }
        } else {
          sortPriority = sortPriority.filter(s => s.col !== col);
        }
		// Update the Sort toggle button text
		updateToggleButtonText('sort');
      } else if (type === 'group') {
        if (e.target.checked) {
          if (!groupByColumns.includes(col)) groupByColumns.push(col);
        } else {
          groupByColumns = groupByColumns.filter(c => c !== col);
        }
		// Update the Group toggle button text
		updateToggleButtonText('group');
      } else if (type === 'hide') {
		if (e.target.checked) {
		  if (!hiddenColumns.includes(col)) hiddenColumns.push(col);
		} else {
		  hiddenColumns = hiddenColumns.filter(c => c !== col);
	    }
	    // Update the Hide toggle button text
		updateToggleButtonText('hide');
	  }
      
      updateTable();
    });
    
    label.appendChild(checkbox);
    label.appendChild(document.createTextNode(` ${col}`));
    checkboxesDiv.appendChild(label);
	
	if (col.includes('closed_')) {
        label.classList.add('closed-col-bg');
    } else if (col.includes('open_')) {
        label.classList.add('open-col-bg');
    }
	
  });
}

// --- Toggle Select All buttons ---
const toggleButton = document.getElementById('toggleSelectAll');
const toggleColorButton = document.getElementById('toggleColorAll');
const toggleSortButton = document.getElementById('toggleSortAll');
const toggleGroupButton = document.getElementById('toggleGroupAll');
const toggleHideButton = document.getElementById('toggleHideAll');
const clearAllFiltersBtn = document.getElementById('clearAllFilters');

toggleButton.addEventListener('click', () => {
  const checkboxes = checkboxesDiv.querySelectorAll('input[type="checkbox"]');
  const allChecked = Array.from(checkboxes).every(cb => cb.checked);

  if (allChecked) {
    checkboxes.forEach(cb => cb.checked = false);
    selectedOrder = [];
    sortPriority = [];
    colorByColumns = [];
    groupByColumns = [];
	hiddenColumns = [];
	updateSelectAllButtonText()  } else {
    checkboxes.forEach(cb => cb.checked = true);
    selectedOrder = Array.from(checkboxes).map(cb => cb.value);
	updateSelectAllButtonText()  }

  updateTable();
});

toggleColorButton.addEventListener('click', () => {
  const checkboxes = document.querySelectorAll('#color-checkboxes input[type="checkbox"]');
  const allChecked = Array.from(checkboxes).every(cb => cb.checked);
  
  checkboxes.forEach(cb => {
    cb.checked = !allChecked;
    const col = cb.value;
    if (!allChecked) {
      if (!colorByColumns.includes(col)) colorByColumns.push(col);
    } else {
      colorByColumns = [];
    }
  });
  
  updateToggleButtonText('color');
  updateTable();
});

toggleSortButton.addEventListener('click', () => {
  const checkboxes = document.querySelectorAll('#sort-checkboxes input[type="checkbox"]');
  const allChecked = Array.from(checkboxes).every(cb => cb.checked);
  
  if (!allChecked) {
    sortPriority = [];
    checkboxes.forEach(cb => {
      cb.checked = true;
      sortPriority.push({ col: cb.value, dir: 'asc' });
    });
  } else {
    checkboxes.forEach(cb => cb.checked = false);
    sortPriority = [];
  }
  
  updateToggleButtonText('sort');
  updateTable();
});

toggleGroupButton.addEventListener('click', () => {
  const checkboxes = document.querySelectorAll('#group-checkboxes input[type="checkbox"]');
  const allChecked = Array.from(checkboxes).every(cb => cb.checked);
  
  checkboxes.forEach(cb => {
    cb.checked = !allChecked;
    const col = cb.value;
    if (!allChecked) {
      if (!groupByColumns.includes(col)) groupByColumns.push(col);
    } else {
      groupByColumns = [];
    }
  });
  
  updateToggleButtonText('group');
  updateTable();
});

toggleHideButton.addEventListener('click', () => {
  const checkboxes = document.querySelectorAll('#hide-checkboxes input[type="checkbox"]');
  const allChecked = Array.from(checkboxes).every(cb => cb.checked);
  
  checkboxes.forEach(cb => {
    cb.checked = !allChecked;
    const col = cb.value;
    if (!allChecked) {
      if (!hiddenColumns.includes(col)) hiddenColumns.push(col);
    } else {
      hiddenColumns = [];
    }
  });
  
  updateToggleButtonText('hide');
  updateTable();
});

clearAllFiltersBtn.addEventListener('click', () => {
  filtersByColumn = {};
  updateTable();
});

// Render filter dropdowns for each selected column
function renderFilterDropdowns(data, displayColumns) {
  const filterContainer = document.getElementById('filter-container');
  const filterDropdownsDiv = document.getElementById('filter-dropdowns');
  
  if (displayColumns.length === 0) {
    filterContainer.style.display = 'none';
    return;
  }
  
  filterContainer.style.display = 'block';
  filterDropdownsDiv.innerHTML = '';
  
  displayColumns.forEach(col => {
    // Get unique values in display order
    const uniqueValues = [];
    const seen = new Set();
    
    data.forEach(row => {
      const val = String(row[col] ?? '');
      if (!seen.has(val)) {
        seen.add(val);
        uniqueValues.push(val);
      }
    });
    
    const filterDiv = document.createElement('div');
    filterDiv.style.marginBottom = '8px';
    filterDiv.style.display = 'inline-block';
    filterDiv.style.marginRight = '15px';
    
    const label = document.createElement('label');
    label.textContent = `${col}: `;
    label.style.marginRight = '5px';
    label.style.fontWeight = 'bold';
    
    const select = document.createElement('select');
    select.name = col;
    select.id = `filter-${col}`;
    select.style.fontFamily = "'Ubuntu Mono', monospace";
    select.style.fontSize = '12px';
    
    // Add "All" option as default
    const allOption = document.createElement('option');
    allOption.value = '__ALL__';
    allOption.textContent = '-- All --';
    select.appendChild(allOption);
    
    // Add unique values
    uniqueValues.forEach(val => {
      const option = document.createElement('option');
      option.value = val;
      option.textContent = val;
      
      // Check if this value is currently selected in filter
      if (filtersByColumn[col] && filtersByColumn[col].includes(val)) {
        option.selected = true;
      }
      
      select.appendChild(option);
    });
    
    // Handle selection changes
    select.addEventListener('change', (e) => {
      const selectedValue = e.target.value;
      
      if (selectedValue === '__ALL__') {
        // Clear filter for this column
        delete filtersByColumn[col];
      } else {
        // Store as array with single value for consistency
        filtersByColumn[col] = [selectedValue];
      }
      
      updateTable();
    });
    
    filterDiv.appendChild(label);
    filterDiv.appendChild(select);
    filterDropdownsDiv.appendChild(filterDiv);
  });
  
    updateFilterButtonText();
}

function updateFilterButtonText() {
  const clearBtn = document.getElementById('clearAllFilters');
  const hasFilters = Object.keys(filtersByColumn).length > 0 && 
                     Object.values(filtersByColumn).some(arr => arr.length > 0);
  
  clearBtn.textContent = hasFilters ? 'Clear Filters' : 'Clear All';
}

// Update table with aggregation and sorting
function updateTable() {
	const selectedColumns = selectedOrder.filter(col =>
	  checkboxesDiv.querySelector(`input[value="${col}"]`).checked
	);

  // Sync color, sort, and group selections with visible columns
	renderSpecialCheckboxes(selectedColumns);

  if (selectedColumns.length === 0) {
    csvTable.innerHTML = '<tr><td>No columns selected</td></tr>';
    rowNumbersDiv.innerHTML = '';
    return;
  }

  // Determine which columns to use for aggregation (visible ones only, or all if grouping is specified)
  let columnsForAggregation = selectedColumns.filter(col => !hiddenColumns.includes(col));
  
  // Aggregate shape_count based on visible columns only
  const groupedData = {};
  let grandTotalCount = 0;
    originalData.forEach(row => {
        const key = columnsForAggregation.map(col => row[col] ?? '').join('|');
        if (!groupedData[key]) {
            groupedData[key] = { ...row };
            groupedData[key][shapeCountCol] = 0;
        }
        groupedData[key][shapeCountCol] += row[shapeCountCol];
        grandTotalCount += row[shapeCountCol];
    });

    let displayData = Object.values(groupedData);

// Collapse open strings if enabled
if (collapseOpenStrings && (originalData.some(row => 'open_fret_numbers' in row) || originalData.some(row => 'open_strings' in row))) {
  const groupedForCollapse = {};
  
  displayData.forEach(row => {
    // Create a key that includes the NON-ZERO/NON-DASH parts of open_fret_numbers and NON-O/NON-DASH parts of open_strings
    let collapsedFretKey = '';
    let collapsedStringsKey = '';
    
    if (row['open_fret_numbers']) {
      const parts = String(row['open_fret_numbers']).split(',').map(p => p.trim());
      // Keep actual numbers, replace 0 and - with placeholder
      collapsedFretKey = parts.map(p => (p === '0' || p === '-') ? '_' : p).join(',');
    }
    
    if (row['open_strings']) {
      const parts = String(row['open_strings']).split(',').map(p => p.trim());
      // Keep X, replace O and - with placeholder
      collapsedStringsKey = parts.map(p => (p === 'O' || p === '-') ? '_' : p).join(',');
    }
    
    // Create key with all columns, but use collapsed versions for the special columns
    const keyParts = columnsForAggregation.map(col => {
      if (col === 'open_fret_numbers') return collapsedFretKey;
      if (col === 'open_strings') return collapsedStringsKey;
      return row[col] ?? '';
    });
    
    const key = keyParts.join('|');
    
    if (!groupedForCollapse[key]) {
      groupedForCollapse[key] = {
        rows: [],
        baseRow: { ...row }
      };
    }
    groupedForCollapse[key].rows.push(row);
  });
  
  // Now collapse each group
  const collapsedData = [];
  
  for (const key in groupedForCollapse) {
    const group = groupedForCollapse[key];
    const rows = group.rows;
    
    const collapsedRow = { ...group.baseRow };
    
    // Collapse open_fret_numbers: merge 0s and -s
    if (rows[0]['open_fret_numbers'] !== undefined) {
      const allParts = rows.map(row => {
        const val = String(row['open_fret_numbers'] ?? '');
        return val.split(',').map(p => p.trim());
      });
      
      const maxLength = Math.max(...allParts.map(p => p.length));
      const merged = [];
      
      for (let i = 0; i < maxLength; i++) {
        // Collect all values at this position
        const valuesAtPos = allParts.map(parts => parts[i]).filter(v => v);
        
        // If there's a real number (not 0 or -), use it
        const realNumber = valuesAtPos.find(v => v !== '0' && v !== '-');
        if (realNumber) {
          merged.push(realNumber);
        } else if (valuesAtPos.includes('0')) {
          // If any has 0, use 0
          merged.push('0');
        } else {
          // Otherwise use -
          merged.push(allParts[0][i] || '-');
        }
      }
      
      collapsedRow['open_fret_numbers'] = merged.join(',');
    }
    
    // Collapse open_strings: merge Os and -s
    if (rows[0]['open_strings'] !== undefined) {
      const allParts = rows.map(row => {
        const val = String(row['open_strings'] ?? '');
        return val.split(',').map(p => p.trim());
      });
      
      const maxLength = Math.max(...allParts.map(p => p.length));
      const merged = [];
      
      for (let i = 0; i < maxLength; i++) {
        // Collect all values at this position
        const valuesAtPos = allParts.map(parts => parts[i]).filter(v => v);
        
        // If there's an X, use it
        const hasX = valuesAtPos.find(v => v === 'X');
        if (hasX) {
          merged.push('X');
        } else if (valuesAtPos.includes('O')) {
          // If any has O, use O
          merged.push('O');
        } else {
          // Otherwise use -
          merged.push(allParts[0][i] || '-');
        }
      }
      
      collapsedRow['open_strings'] = merged.join(',');
    }
    
    collapsedRow[shapeCountCol] = rows.reduce((sum, r) => sum + r[shapeCountCol], 0);
    
    collapsedData.push(collapsedRow);
  }
  
  displayData = collapsedData;
}

	// Apply filters
	if (Object.keys(filtersByColumn).length > 0) {
	  displayData = displayData.filter(row => {
		for (const col in filtersByColumn) {
		  const selectedValues = filtersByColumn[col];
		  if (selectedValues.length > 0) {
			const rowValue = String(row[col] ?? '');
			if (!selectedValues.includes(rowValue)) {
			  return false;
			}
		  }
		}
		return true;
	  });
	}

  // Apply multi-level sort
  if (sortPriority.length > 0) {
  displayData.sort((a, b) => {
    for (let s of sortPriority) {
      const col = s.col;
      let valA = a[col] ?? '';
      let valB = b[col] ?? '';

      // --- Custom sorting rules ---
      if (col === 'closed_strings' || col === 'open_strings') {
        const keyA = valA.split(',').map(v => (v.trim() === 'X' ? '1' : '0')).join('');
        const keyB = valB.split(',').map(v => (v.trim() === 'X' ? '1' : '0')).join('');
        if (keyA < keyB) return s.dir === 'asc' ? -1 : 1;
        if (keyA > keyB) return s.dir === 'asc' ? 1 : -1;
      } 
		else if (col === 'closed_fret_numbers' || col === 'open_fret_numbers') {
		        
		        const getSortKeyAndList = (val) => {
		            const cleanVal = String(val).replace(/-/g, '-1');
		            const list = cleanVal.split(',').map(v => Number(v.trim()));
		            
		            let firstFretIndex = list.length;
		            let firstFretValue = -Infinity;
		            
		            for (let i = 0; i < list.length; i++) {
		                const num = list[i];
		                if (num > 0) {
		                    firstFretIndex = i;
		                    firstFretValue = num;
		                    break;
		                }
		            }
		            
		            const compositeKey = firstFretIndex * 1000 + firstFretValue;

		            return { compositeKey, list };
		        };

		        const { compositeKey: keyA, list: listA } = getSortKeyAndList(valA);
		        const { compositeKey: keyB, list: listB } = getSortKeyAndList(valB);

		        if (keyA < keyB) return s.dir === 'asc' ? -1 : 1;
		        if (keyA > keyB) return s.dir === 'asc' ? 1 : -1;

		        const len = Math.max(listA.length, listB.length);
		        
		        for (let i = 0; i < len; i++) {
		            const aNum = listA[i] ?? -Infinity;
		            const bNum = listB[i] ?? -Infinity;
		            
		            if (aNum < bNum) return s.dir === 'asc' ? -1 : 1;
		            if (aNum > bNum) return s.dir === 'asc' ? 1 : -1;
		        }
		        continue;
		}

	else if (col === 'closed_formula_ext' || col === 'open_formula_ext') {
	  const cleanValA = String(valA).replace(/-/g, '');
	  const cleanValB = String(valB).replace(/-/g, '');

	  const listA = cleanValA.split(',').map(v => Number(v.trim()));
	  const listB = cleanValB.split(',').map(v => Number(v.trim()));
	  
	  if (listA.length !== listB.length) {
			const lenA = listA.length;
			const lenB = listB.length;
			if (lenA < lenB) return s.dir === 'asc' ? -1 : 1;
			if (lenA > lenB) return s.dir === 'asc' ? 1 : -1;
	  }
	  
	  const len = Math.max(listA.length, listB.length);
	  
	  for (let i = 0; i < len; i++) {
		const aNum = listA[i] ?? -Infinity;
		const bNum = listB[i] ?? -Infinity;
		
		if (aNum < bNum) return s.dir === 'asc' ? -1 : 1;
		if (aNum > bNum) return s.dir === 'asc' ? 1 : -1;
	  }
	  continue;
	} 

      else {
        if (valA < valB) return s.dir === 'asc' ? -1 : 1;
        if (valA > valB) return s.dir === 'asc' ? 1 : -1;
      }
    }
    return 0;
  });
}

	// Hide insignificant rows if enabled
	if (hideInsignificant) {
	  if (proportionalCountEnabled && groupByColumns.length > 0) {
		// Build group totals
		const groupTotals = new Map();
		displayData.forEach(row => {
		  const groupKey = groupByColumns.map(col => row[col] ?? '').join('|');
		  if (!groupTotals.has(groupKey)) {
			groupTotals.set(groupKey, 0);
		  }
		  groupTotals.set(groupKey, groupTotals.get(groupKey) + row[shapeCountCol]);
		});
		
		// Filter out rows < 1%
		displayData = displayData.filter(row => {
		  const groupKey = groupByColumns.map(col => row[col] ?? '').join('|');
		  const total = groupTotals.get(groupKey) || 0;
		  if (total === 0) return false;
		  const percentage = (row[shapeCountCol] / total) * 100;
		  return percentage >= 1.0;
		});
	  } else {
		// Use grand total
		const total = displayData.reduce((sum, row) => sum + row[shapeCountCol], 0);
		if (total > 0) {
		  displayData = displayData.filter(row => {
			const percentage = (row[shapeCountCol] / total) * 100;
			return percentage >= 1.0;
		  });
		}
	  }
	}

	for (const col in filtersByColumn) {
	    if (!selectedColumns.includes(col)) {
	        delete filtersByColumn[col];
	    }
	}

	renderFilterDropdowns(displayData, selectedColumns);

    renderTable(displayData, selectedColumns);
	  renderRowNumbers(displayData.length);
	  renderSortInstructions();
}

// Render row numbers
function renderRowNumbers(rowCount) {
  rowNumbersDiv.innerHTML = '';
  
  // Calculate how many separator rows we need to add
  let totalRows = rowCount;
  if (proportionalCountEnabled && groupByColumns.length > 0) {
    // Count unique groups
    // This is approximate - the actual count happens in renderTable
    totalRows = rowCount * 1.2; // Add some buffer for separators
  }
  
  for (let i = 1; i <= totalRows; i++) {
    const div = document.createElement('div');
    div.textContent = i <= rowCount ? i : '';
    rowNumbersDiv.appendChild(div);
  }
}

// Render table
function renderTable(data, displayColumns) {
	const visibleColumns = displayColumns.filter(col => !hiddenColumns.includes(col));  
	const isCountHidden = hiddenColumns.includes(shapeCountCol); 
	
  csvTable.innerHTML = '';
  if (data.length === 0) return;

  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');

  const countHeader = proportionalCountEnabled ? `${shapeCountCol} (%)` : shapeCountCol;

  visibleColumns.forEach(col => {
    const th = document.createElement('th');
    th.textContent = col;
    th.classList.add('sortable');
    th.addEventListener('click', (e) => { if (e.detail===1) toggleSort(col); });
    th.addEventListener('dblclick', () => removeSort(col));
    const sp = sortPriority.findIndex(s => s.col===col);
    if (sp >=0){ const indicator=document.createElement('span'); indicator.classList.add('sort-indicator'); indicator.textContent = sp+1; th.appendChild(indicator);}
    headerRow.appendChild(th);
  });
  
  // **Wrap the count column creation with a check for hiding:**
if (!isCountHidden) { 
	  const thCount = document.createElement('th');
	  thCount.textContent = countHeader;
	  thCount.classList.add('sortable');
	  thCount.addEventListener('click', (e) => { if (e.detail===1) toggleSort(shapeCountCol); });
	  thCount.addEventListener('dblclick', () => removeSort(shapeCountCol));
	  const spCount = sortPriority.findIndex(s => s.col===shapeCountCol);
	  if(spCount>=0){ const indicator=document.createElement('span'); indicator.classList.add('sort-indicator'); indicator.textContent=spCount+1; thCount.appendChild(indicator);}
	  headerRow.appendChild(thCount);
	}

  thead.appendChild(headerRow);
  csvTable.appendChild(thead);

const tbody = document.createElement('tbody');

// Calculate grand total from CURRENT displayData (after filtering)
const grandTotal = data.map(r => r[shapeCountCol]).reduce((acc, val) => acc + val, 0);

// --- Determine color grouping logic ---
let colorKeyFn;
let columnsForColoring = [];

if (colorByColumns.length > 0) {
  columnsForColoring = colorByColumns.filter(c => c !== shapeCountCol);
  colorKeyFn = row => columnsForColoring.map(c => row[c] ?? "").join("|");
} else {
  columnsForColoring = displayColumns;
  colorKeyFn = row => columnsForColoring.map(c => row[c] ?? "").join("|");
}

const uniqueKeys = [...new Set(data.map(colorKeyFn))];
const colorMap = new Map();
uniqueKeys.forEach((key, i) => {
  colorMap.set(key, rainbowColors[i % rainbowColors.length]);
});

let previousRow = null;

	// --- Proportional Calculation Setup --- 
	const groupTotalMap = new Map();

	if (proportionalCountEnabled && groupByColumns.length > 0) {
		// Use ONLY the selected group columns (not all visible columns)
		const visibleGroupCols = groupByColumns.filter(col => visibleColumns.includes(col) || displayColumns.includes(col));
		
		data.forEach(row => {
			const groupKey = visibleGroupCols.map(col => row[col] ?? '').join('|');
			if (!groupTotalMap.has(groupKey)) {
				groupTotalMap.set(groupKey, 0);
			}
			groupTotalMap.set(groupKey, groupTotalMap.get(groupKey) + row[shapeCountCol]);
		});
	}

let currentGroupKey = '';
let currentGroupTotal = 0;

data.forEach((row, rowIndex) => {
      const tr = document.createElement('tr');  
	  tr._rowData = row;
	  
	  const rowColor = colorMap.get(colorKeyFn(row));
	  tr._rowColor = rowColor;
	  tr.style.backgroundColor = rowColor + "20";
		  
  		let isChainBroken = false;
		
	visibleColumns.forEach((col, colIndex) => {
	  const td = document.createElement('td');
	  let showValue = true;

	  if (previousRow) {
		// Check if current column matches previous row
		if (row[col] === previousRow[col]) {
		  // Check if any column to the left has a different value
		  let hasUniqueLeft = false;
		  for (let i = 0; i < colIndex; i++) {
			const leftCol = visibleColumns[i];
			if (row[leftCol] !== previousRow[leftCol]) {
			  hasUniqueLeft = true;
			  break;
			}
		  }
		  
		  // Only hide if no unique value to the left
		  if (!hasUniqueLeft) {
			showValue = false;
			td.style.backgroundColor = '#FFFFFF';
			td.style.setProperty('border', 'none', 'important');
		  }
		}
	  }

	  td.textContent = showValue ? (row[col] ?? '') : '';
	  
	  tr.appendChild(td);
	});

if (!isCountHidden) {
    const tdCount = document.createElement('td');
    let countValue = row[shapeCountCol] ?? 0;

	if (proportionalCountEnabled) {
		let total = 0;

		if (groupByColumns.length > 0) {
			const visibleGroupCols = groupByColumns.filter(col => visibleColumns.includes(col) || displayColumns.includes(col));
			const groupKey = visibleGroupCols.map(col => row[col] ?? '').join('|');
			total = groupTotalMap.get(groupKey) || 0;
			
			// Track group changes for separator rows
			if (groupKey !== currentGroupKey) {
				currentGroupKey = groupKey;
				currentGroupTotal = total;
			}
		} else {
			total = grandTotal;
		}

		if (total > 0) {
			const percentage = (countValue / total) * 100;
			tdCount.textContent = percentage.toFixed(1);
		} else {
			tdCount.textContent = '0.0';
		}
	} else {
		tdCount.textContent = countValue;
	}
	
	let maxCount = Math.max(...data.map(r => r[shapeCountCol]));
	let normalized = countValue / maxCount;
	let alpha = Math.min(Math.max(normalized, 0), 1);
	let grayscale = Math.round(255 * (1 - normalized));
	
	tdCount.style.backgroundColor = `rgb(${grayscale},${grayscale},${grayscale})`;
	tdCount.style.color = normalized > 0.5 ? 'white' : 'black';
	
	tr.appendChild(tdCount);
}

	tbody.appendChild(tr);
	
	// Add separator row with total if we're at the end of a group
	if (proportionalCountEnabled && groupByColumns.length > 0 && rowIndex < data.length - 1) {
		const visibleGroupCols = groupByColumns.filter(col => visibleColumns.includes(col) || displayColumns.includes(col));
		const nextGroupKey = visibleGroupCols.map(col => data[rowIndex + 1][col] ?? '').join('|');
		
		if (nextGroupKey !== currentGroupKey) {
			// Create separator row
			const separatorTr = document.createElement('tr');
			separatorTr.style.backgroundColor = 'transparent';
			separatorTr.style.textDecoration = "underline";
			
			visibleColumns.forEach(() => {
				const td = document.createElement('td');
				td.style.border = 'none';
				td.style.backgroundColor = 'transparent';
				separatorTr.appendChild(td);
			});
			
			if (!isCountHidden) {
			const totalTd = document.createElement('td');
			totalTd.style.backgroundColor = 'transparent';
			totalTd.style.border = 'none';
			totalTd.textContent = proportionalCountEnabled ? '100.0' : currentGroupTotal;
			separatorTr.appendChild(totalTd);
			}
			
			tbody.appendChild(separatorTr);
		}
	}
	
	previousRow = row;
});

// Add final separator row if proportional grouping is enabled
if (proportionalCountEnabled && groupByColumns.length > 0 && data.length > 0) {
	const separatorTr = document.createElement('tr');
	separatorTr.style.backgroundColor = 'transparent';
	separatorTr.style.textDecoration = "underline";
	
	visibleColumns.forEach(() => {
		const td = document.createElement('td');
		td.style.border = 'none';
		td.style.backgroundColor = 'transparent';
		separatorTr.appendChild(td);
	});
	
	if (!isCountHidden) {
	const totalTd = document.createElement('td');
	totalTd.style.backgroundColor = 'transparent';
	totalTd.style.border = 'none';
	totalTd.textContent = proportionalCountEnabled ? '100.0' : currentGroupTotal;
	separatorTr.appendChild(totalTd);
	}
	
	tbody.appendChild(separatorTr);
}

csvTable.appendChild(tbody);

}

// Toggle sorting
function toggleSort(col){
  const existing = sortPriority.find(s => s.col === col);
  
  const checkbox = checkboxesDiv.querySelector(`input[value="${col}"]`);
  if (checkbox) {
    checkbox.checked = true;
    if (!selectedOrder.includes(col)) {
      selectedOrder.push(col);
    }
  }

  if (!existing) {  
    sortPriority.push({col, dir:'asc'});
  } else {
    existing.dir = existing.dir === 'asc' ? 'desc' : 'asc';
  }
  updateTable();
}

// Remove column from sort
function removeSort(col){
  sortPriority=sortPriority.filter(s=>s.col!==col);
  updateTable();
}

function renderSortInstructions(){
  let instructions = '';
  
  if (sortPriority.length > 0) {
    instructions += 'Sort priority (click headers to toggle A-Z / Z-A, dblclick to remove): ' +
      sortPriority.map((s,i)=>`${i+1}: ${s.col} (${s.dir.toUpperCase()})`).join(' | ');
  }

  if (colorByColumns.length > 0) {
    let colorDisplay = `Color Grouping: ${colorByColumns.join(', ')}`;
    if (instructions) {
      instructions += '<br/>' + colorDisplay;
    } else {
      instructions = colorDisplay;
    }
  }

  if (groupByColumns.length > 0 && proportionalCountEnabled) {
    let groupDisplay = `Proportions Grouped By: ${groupByColumns.join(', ')}`;
    if (instructions) {
      instructions += '<br/>' + groupDisplay;
    } else {
      instructions = groupDisplay;
    }
  }

  sortInstructionsDiv.innerHTML = instructions;
}

</script>

</body>

</html>


