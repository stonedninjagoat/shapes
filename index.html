<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Shapes Table</title>
<link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<style>
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  font-family: 'Ubuntu Mono', monospace;
  display: flex;
  flex-direction: column;
}

body {
  padding: 10px;
}

#controls {
  margin-bottom: 10px;
}

.file-btn, button {
  display: inline-block;   /* only as wide as content */
  width: auto;
  font-family: 'Ubuntu Mono', monospace;
  font-size: 14px;
  padding: 5px 10px;
  border: 1px solid #000;
  border-radius: 4px;
  background-color: #eee;
  cursor: pointer;
  margin-right: 10px;
  text-align: center;
  vertical-align: middle;
}

.file-btn {
  position: relative;
  overflow: hidden;
}

.file-btn input[type="file"] {
  position: absolute;
  left: 0;
  top: 0;
  opacity: 0;
  width: 100%;
  height: 100%;
  cursor: pointer;
}

#column-checkboxes, #sort-instructions { margin: 10px 0; }

#color-checkboxes-container label { margin-right: 15px; }

.table-container {
  display: flex;
  flex: 1;
  overflow: hidden;
}

.row-numbers {
  text-align: right;
  margin-right: 5px;
  font-size: 12px;
  line-height: 22px;
  overflow-y: auto;
}

.table-wrapper {
  flex: 1;
  overflow: auto;
}

table {
  border-collapse: collapse;
  width: 100%;   /* table fills wrapper width */
  table-layout: auto;
  font-family: 'Ubuntu Mono', monospace;
}

th, td {
  border: 1px solid black;
  padding: 5px;
  text-align: center;
  vertical-align: middle;
  white-space: nowrap;
}

thead th {
  position: sticky;
  top: 0;
  background: #eee;
  z-index: 2;
}

th.sortable { cursor: pointer; text-decoration: underline; }
.sort-indicator { font-size: 8px; color: gray; margin-left: 2px; }
</style>
</head>
<body>

<h2>Shapes Table</h2>

<div id="controls">
  <label class="file-btn">
    Choose File
    <input type="file" id="csvFile" accept=".csv" />
  </label>
  <button id="toggleSelectAll">Select All</button>
</div>

<div id="column-checkboxes"></div>
<div id="sort-instructions"></div>
<div id="color-checkboxes-container" style="margin: 10px 0;"></div>

<div class="table-container">
  <div class="row-numbers" id="rowNumbers"></div>
  <div class="table-wrapper">
    <table id="csvTable"></table>
  </div>
</div>
  
<script>
let originalData = [];
let headers = [];
let sortPriority = [];
let selectedOrder = []; 

const shapeCountCol = 'count';
const rainbowColors = [
  "#FF0000", "#FF7F00", "#FFFF00", "#00FF00", "#0000FF", "#4B0082", "#8B00FF",
  "#FF1493", "#00CED1", "#ADFF2F", "#FF6347", "#20B2AA"
];

const csvFileInput = document.getElementById('csvFile');
const checkboxesDiv = document.getElementById('column-checkboxes');
const sortInstructionsDiv = document.getElementById('sort-instructions');
const csvTable = document.getElementById('csvTable');
const rowNumbersDiv = document.getElementById('rowNumbers');
const tableWrapperDiv = document.querySelector('.table-wrapper');
const defaultCsvUrl = 'https://raw.githubusercontent.com/stonedninjagoat/shapes/refs/heads/main/shapesEvery.csv';

function loadCsvFromUrl(url) {
  Papa.parse(url, {
    download: true,
    header: true,
    skipEmptyLines: true,
    dynamicTyping: true,
    complete: function(results) {
      originalData = results.data.map(row => {
        row[shapeCountCol] = Number(row[shapeCountCol] || 0);
        return row;
      });
      headers = results.meta.fields.filter(f => f !== shapeCountCol);
      selectedOrder = [];
      renderCheckboxes();
      updateTable();
    }
  });
}

loadCsvFromUrl(defaultCsvUrl);

csvFileInput.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;

  Papa.parse(file, {
    header: true,
    skipEmptyLines: true,
    dynamicTyping: true,
    complete: function(results) {
      originalData = results.data.map(row => {
        row[shapeCountCol] = Number(row[shapeCountCol] || 0);
        return row;
      });
      headers = results.meta.fields.filter(f => f !== shapeCountCol);
      selectedOrder = [];
      renderCheckboxes();
      updateTable();
    }
  });
});
  
// Upload CSV
csvFileInput.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;

  Papa.parse(file, {
    header: true,
    skipEmptyLines: true,
    dynamicTyping: false,
    complete: function(results) {
      originalData = results.data.map(row => {
        row[shapeCountCol] = Number(row[shapeCountCol] || 0);
        return row;
      });
      headers = results.meta.fields.filter(f => f !== shapeCountCol);
      selectedOrder = [];
      renderCheckboxes();
      updateTable();
    }
  });
});

// Render column checkboxes
function renderCheckboxes() {
  checkboxesDiv.innerHTML = '';
  headers.forEach(header => {
    const label = document.createElement('label');
    label.innerHTML = `<input type="checkbox" value="${header}"> ${header}`;
    checkboxesDiv.appendChild(label);
  });

  checkboxesDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => {
  cb.addEventListener('change', (e) => {
    const col = e.target.value;

    if (e.target.checked) {
      // Add column to end of selection order
      selectedOrder.push(col);
    } else {
      // Remove column if unchecked
      selectedOrder = selectedOrder.filter(c => c !== col);
      // Also remove from sortPriority if present
      sortPriority = sortPriority.filter(s => s.col !== col);
    }

    updateTable();
  });
});

}

// Render color selection checkboxes
function renderColorCheckboxes(visibleCols) {
  const container = document.getElementById('color-checkboxes-container');
  container.innerHTML = ''; // Clear existing checkboxes

  if (visibleCols.length === 0) {
    container.style.display = 'none';
    return;
  }
  
  container.style.display = 'block';
  const title = document.createElement('span');
  title.textContent = 'Color By: ';
  title.style.fontWeight = 'bold';
  container.appendChild(title);

  const allColsForColoring = [...visibleCols, shapeCountCol];
  
  // Get current sort priority columns for checking state
  const sortedCols = sortPriority.map(s => s.col);

  allColsForColoring.forEach(col => {
    const label = document.createElement('label');
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.value = col;
    
    // Check if the column is currently in sortPriority
    checkbox.checked = sortedCols.includes(col);

    //  Since color/sort are unified, clicking this should remove/add to sortPriority
    checkbox.addEventListener('change', (e) => {
      if (e.target.checked) {
        // If checked, add to sortPriority (default to ascending, no 3-limit)
        if (!sortedCols.includes(col)) {
             sortPriority.push({ col, dir: 'asc' });
        }
      } else {
        // If unchecked, remove from sortPriority
        sortPriority = sortPriority.filter(s => s.col !== col);
      }
      updateTable();
    });

    label.appendChild(checkbox);
    label.appendChild(document.createTextNode(` ${col}`));
    container.appendChild(label);
  });
}

// --- Toggle Select All / Deselect All ---
const toggleButton = document.getElementById('toggleSelectAll');

toggleButton.addEventListener('click', () => {
  const checkboxes = checkboxesDiv.querySelectorAll('input[type="checkbox"]');
  const allChecked = Array.from(checkboxes).every(cb => cb.checked);

  if (allChecked) {
    // Deselect all
    checkboxes.forEach(cb => cb.checked = false);
    selectedOrder = [];
    sortPriority = [];
    toggleButton.textContent = 'Select All';
  } else {
    // Select all
    checkboxes.forEach(cb => cb.checked = true);
    selectedOrder = Array.from(checkboxes).map(cb => cb.value); // update order list
    toggleButton.textContent = 'Deselect All';
  }

  updateTable();
});

// Update table with aggregation and sorting
function updateTable() {
const selectedColumns = selectedOrder.filter(col =>
  checkboxesDiv.querySelector(`input[value="${col}"]`).checked
);

  // Sync color selections with visible columns
  renderColorCheckboxes(selectedColumns);

  if (selectedColumns.length === 0) {
    csvTable.innerHTML = '<tr><td>No columns selected</td></tr>';
    rowNumbersDiv.innerHTML = '';
    return;
  }

  // Aggregate shape_count based on selected columns
  const groupedData = {};
  originalData.forEach(row => {
    const key = selectedColumns.map(col => row[col] ?? '').join('|');
    if (!groupedData[key]) {
      groupedData[key] = { ...row };
      groupedData[key][shapeCountCol] = 0;
    } else {
    // Keep formula_ext as the first row's value (or merge if needed)
  }
    groupedData[key][shapeCountCol] += row[shapeCountCol];
  });

  let displayData = Object.values(groupedData);

  // Apply multi-level sort
  if (sortPriority.length > 0) {
  displayData.sort((a, b) => {
    for (let s of sortPriority) {
      const col = s.col;
      let valA = a[col] ?? '';
      let valB = b[col] ?? '';

      // --- Custom sorting rules ---
      if (col === 'closed_strings' || col === 'open_strings') {
        // Convert to binary sort key (X = 1, others = 0)
        const keyA = valA.split(',').map(v => (v.trim() === 'X' ? '1' : '0')).join('');
        const keyB = valB.split(',').map(v => (v.trim() === 'X' ? '1' : '0')).join('');
        if (keyA < keyB) return s.dir === 'asc' ? -1 : 1;
        if (keyA > keyB) return s.dir === 'asc' ? 1 : -1;
      } 
else if (col === 'closed_formula_ext' || col === 'closed_fret_numbers' || col === 'open_formula_ext' || col === 'open_fret_numbers' ) {
  const cleanValA = String(valA).replace(/-/g, '');
  const cleanValB = String(valB).replace(/-/g, '');

  const listA = cleanValA.split(',').map(v => Number(v.trim()));
  const listB = cleanValB.split(',').map(v => Number(v.trim()));
  
  const len = Math.max(listA.length, listB.length);
  
  for (let i = 0; i < len; i++) {
    // Treat missing numbers as -Infinity for consistent comparison
    const aNum = listA[i] ?? -Infinity;
    const bNum = listB[i] ?? -Infinity;
    
    if (aNum < bNum) return s.dir === 'asc' ? -1 : 1;
    if (aNum > bNum) return s.dir === 'asc' ? 1 : -1;
  }
  continue; // if all equal, check next priority column
}

      else {
        // Default string comparison
        if (valA < valB) return s.dir === 'asc' ? -1 : 1;
        if (valA > valB) return s.dir === 'asc' ? 1 : -1;
      }
    }
    return 0;
  });
}

  renderTable(displayData, selectedColumns);
  renderRowNumbers(displayData.length);
  renderSortInstructions();
}

// Render row numbers
function renderRowNumbers(rowCount) {
  rowNumbersDiv.innerHTML = '';
  for (let i = 1; i <= rowCount; i++) {
    const div = document.createElement('div');
    div.style.height = '22px';
    div.textContent = i;
    rowNumbersDiv.appendChild(div);
  }
}

// Synchronize scrolling
tableWrapperDiv.addEventListener('scroll', () => {
  rowNumbersDiv.scrollTop = tableWrapperDiv.scrollTop;
});

// Render table
function renderTable(data, displayColumns) {
  csvTable.innerHTML = '';
  if (data.length === 0) return;

  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');

  displayColumns.forEach(col => {
    const th = document.createElement('th');
    th.textContent = col;
    th.classList.add('sortable');
    th.addEventListener('click', (e) => { if (e.detail===1) toggleSort(col); });
    th.addEventListener('dblclick', () => removeSort(col));
    const sp = sortPriority.findIndex(s => s.col===col);
    if (sp >=0){ const indicator=document.createElement('span'); indicator.classList.add('sort-indicator'); indicator.textContent = sp+1; th.appendChild(indicator);}
    headerRow.appendChild(th);
  });

  // shape_count at end
  const thCount = document.createElement('th');
  thCount.textContent = shapeCountCol;
  thCount.classList.add('sortable');
  thCount.addEventListener('click', (e) => { if (e.detail===1) toggleSort(shapeCountCol); });
  thCount.addEventListener('dblclick', () => removeSort(shapeCountCol));
  const spCount = sortPriority.findIndex(s => s.col===shapeCountCol);
  if(spCount>=0){ const indicator=document.createElement('span'); indicator.classList.add('sort-indicator'); indicator.textContent=spCount+1; thCount.appendChild(indicator);}
  headerRow.appendChild(thCount);

  thead.appendChild(headerRow);
  csvTable.appendChild(thead);

// Table body
const tbody = document.createElement('tbody');

// --- Determine color grouping logic ---
	let colorKeyFn;
	let columnsForColoring = [];

  if (sortPriority.length > 0) {
    // 1. Prioritize manually selected color columns
    columnsForColoring = sortPriority.map(s => s.col);
  } else {
    // 3. Final fallback to all displayed columns
    columnsForColoring = displayColumns;
  }
  
  const finalColorCols = columnsForColoring.filter(c => c !== shapeCountCol);
  colorKeyFn = row => finalColorCols.map(c => row[c] ?? "").join("|");

// Get unique group keys
const uniqueKeys = [...new Set(data.map(colorKeyFn))];
const colorMap = new Map();
uniqueKeys.forEach((key, i) => {
  colorMap.set(key, rainbowColors[i % rainbowColors.length]);
});

let previousRow = null; // To track the previous row's data

// Apply colors and new display logic row-by-row
data.forEach(row => {
  const tr = document.createElement('tr');
  const rowColor = colorMap.get(colorKeyFn(row));
  tr.style.backgroundColor = rowColor + "20"; // add transparency (20 hex ≈ 12%)
  
  let isChainBroken = false; // Flag to check if the sequence of identical values is broken

  displayColumns.forEach(col => {
    const td = document.createElement('td');
    let showValue = true;

    // If it's not the first row and the chain of identical values isn't broken
    if (previousRow && !isChainBroken) {
      if (row[col] === previousRow[col]) {
        showValue = false; // Value is the same as the one above, hide it
      } else {
        isChainBroken = true; // Chain is broken, show this value and all subsequent ones in the row
      }
    }
    
    td.textContent = showValue ? (row[col] ?? '') : '';
    tr.appendChild(td);
  });

    const tdCount = document.createElement('td');
    tdCount.textContent = row[shapeCountCol] ?? 0; 
    tr.appendChild(tdCount);
  
  tbody.appendChild(tr);
  previousRow = row; // Update previousRow for the next iteration
});

csvTable.appendChild(tbody);

}

// Toggle sorting
function toggleSort(col){
  const existing = sortPriority.find(s => s.col === col);
  
  const checkbox = checkboxesDiv.querySelector(`input[value="${col}"]`);
  if (checkbox) {
    checkbox.checked = true;
    if (!selectedOrder.includes(col)) {
      selectedOrder.push(col); // Add to display order if not present
    }
  }

  if (!existing) {  
    sortPriority.push({col, dir:'asc'}); // add new column to end = lowest priority
  } else {
    existing.dir = existing.dir === 'asc' ? 'desc' : 'asc';
  }
  updateTable();
}

// Remove column from sort
function removeSort(col){
  sortPriority=sortPriority.filter(s=>s.col!==col);
  updateTable();
}

function renderSortInstructions(){
  // Initialize instructions string
  let instructions = '';
  
  if (sortPriority.length > 0) {
    instructions += 'Sort priority (click headers to toggle A-Z / Z-A, dblclick to remove): ' +
      sortPriority.map((s,i)=>`${i+1}: ${s.col} (${s.dir.toUpperCase()})`).join(' | ');
  }

  // --- Determine which columns are CURRENTLY being used for coloring ---
  let coloringCols = [];
  
  // Get currently selected columns to determine visible columns for fallback
  const selectedColumns = selectedOrder.filter(col => {
    const cb = checkboxesDiv.querySelector(`input[value="${col}"]`);
    return cb && cb.checked;
  });

  if (sortPriority.length > 0) {
    coloringCols = sortPriority.map(s => s.col).filter(c => c !== shapeCountCol && selectedColumns.includes(c));
  } else {
    coloringCols = selectedColumns.filter(c => c !== shapeCountCol);
  }

  if (coloringCols.length > 0) {
    const colorSource = sortPriority.length > 0 ? 'Sort Priority' : 
                        'All Visible Cols';
    
    let colorDisplay = `Color Grouping (Source: ${colorSource}): ${coloringCols.join(', ')}`;
    
    if (instructions) {
      instructions += '<br/>' + colorDisplay;
    } else {
      instructions = colorDisplay;
    }
  }

  // Update the instruction div
  sortInstructionsDiv.innerHTML = instructions;
}

</script>

</body>
</html>